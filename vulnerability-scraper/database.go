// database.go
package main

import (
	"database/sql"
	"log"
	"strings"

	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
)

// Database an Kapselung der Datenbankverbindung
type Database struct {
	*sqlx.DB
}

// NewDatabase stellt eine neue Datenbankverbindung her
func NewDatabase(dsn string) (*Database, error) {
	db, err := sqlx.Connect("mysql", dsn)
	if err != nil {
		return nil, err
	}
	return &Database{db}, nil
}

// SaveVulnerability ist die Hauptfunktion zum Speichern einer Sicherheitslücke.
// Sie ist transaktional und kümmert sich um die Erstellung von Herstellern/Produkten.
func (db *Database) SaveVulnerability(vuln *Vulnerability) error {
	// Start transaction
	tx, err := db.Beginx()
	if err != nil {
		return err
	}
	// Defer a rollback in case of error
	defer tx.Rollback()

	// 1. Get or create vendor
	vendorID, err := getOrCreate(tx, "vendors", "name", vuln.VendorName)
	if err != nil {
		log.Printf("处理厂商失败 '%s': %v", vuln.VendorName, err)
		return err
	}

	// 2. Get or create product
	productID, err := getOrCreateProduct(tx, vendorID, vuln.ProductName)
	if err != nil {
		log.Printf("处理产品失败 '%s': %v", vuln.ProductName, err)
		return err
	}

	// 3. Insert or update vulnerability
	stmt := `
        INSERT INTO vulnerability_kb (
            product_id, source_platform, source_id, vuln_name, vuln_description, 
            vuln_severity, published_at, patch_info
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE
            vuln_name = VALUES(vuln_name),
            vuln_description = VALUES(vuln_description),
            vuln_severity = VALUES(vuln_severity),
            patch_info = VALUES(patch_info)
    `

	// Severity mapping
	var severity sql.NullString
	if vuln.Severity != "" {
		s := strings.ToUpper(vuln.Severity)
		if s == "高" {
			severity.String = "HIGH"
		} else if s == "中" {
			severity.String = "MEDIUM"
		} else if s == "低" {
			severity.String = "LOW"
		}
		if severity.String != "" {
			severity.Valid = true
		}
	}

	// Published date parsing
	var publishedAt sql.NullString
	if len(vuln.PublishedAt) >= 10 {
		publishedAt.String = vuln.PublishedAt[:10]
		publishedAt.Valid = true
	}

	_, err = tx.Exec(stmt, productID, "CNVD", vuln.CNVD_ID, vuln.Title, vuln.Description, severity, publishedAt, vuln.PatchInfo)
	if err != nil {
		log.Printf("插入漏洞失败 %s: %v", vuln.CNVD_ID, err)
		return err
	}

	// Commit the transaction
	if err := tx.Commit(); err != nil {
		return err
	}

	log.Printf("成功保存漏洞: %s - %s", vuln.CNVD_ID, vuln.Title)
	return nil
}

// getOrCreate ist eine Hilfsfunktion, um einen Eintrag in einer einfachen Nachschlagetabelle zu erhalten oder zu erstellen
func getOrCreate(tx *sqlx.Tx, tableName, fieldName, value string) (int64, error) {
	var id int64
	if value == "" {
		value = "N/A" // Default value if empty
	}

	// Try to get
	err := tx.Get(&id, "SELECT id FROM "+tableName+" WHERE "+fieldName+" = ?", value)
	if err == nil {
		return id, nil // Found
	}

	if err != sql.ErrNoRows {
		return 0, err // Real error
	}

	// Not found, so create it
	res, err := tx.Exec("INSERT INTO "+tableName+" ("+fieldName+") VALUES (?)", value)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

// getOrCreateProduct ist eine spezielle Version für die Produkttabelle
func getOrCreateProduct(tx *sqlx.Tx, vendorID int64, productName string) (int64, error) {
	var id int64
	if productName == "" {
		productName = "N/A"
	}

	err := tx.Get(&id, "SELECT id FROM products WHERE vendor_id = ? AND name = ?", vendorID, productName)
	if err == nil {
		return id, nil
	}
	if err != sql.ErrNoRows {
		return 0, err
	}

	res, err := tx.Exec("INSERT INTO products (vendor_id, name) VALUES (?, ?)", vendorID, productName)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}
